// Source: contracts/interfaces/IAxelarServiceGovernance.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

// File contracts/interfaces/IAxelarGateway.sol

interface IAxelarGateway {
    /**********\
    |* Errors *|
    \**********/

    error NotSelf();
    error NotProxy();
    error InvalidCodeHash();
    error SetupFailed();
    error InvalidAuthModule();
    error InvalidTokenDeployer();
    error InvalidAmount();
    error InvalidChainId();
    error InvalidCommands();
    error TokenDoesNotExist(string symbol);
    error TokenAlreadyExists(string symbol);
    error TokenDeployFailed(string symbol);
    error TokenContractDoesNotExist(address token);
    error BurnFailed(string symbol);
    error MintFailed(string symbol);
    error InvalidSetMintLimitsParams();
    error ExceedMintLimit(string symbol);

    /**********\
    |* Events *|
    \**********/

    event TokenSent(
        address indexed sender,
        string destinationChain,
        string destinationAddress,
        string symbol,
        uint256 amount
    );

    event ContractCall(
        address indexed sender,
        string destinationChain,
        string destinationContractAddress,
        bytes32 indexed payloadHash,
        bytes payload
    );

    event ContractCallWithToken(
        address indexed sender,
        string destinationChain,
        string destinationContractAddress,
        bytes32 indexed payloadHash,
        bytes payload,
        string symbol,
        uint256 amount
    );

    event Executed(bytes32 indexed commandId);

    event TokenDeployed(string symbol, address tokenAddresses);

    event ContractCallApproved(
        bytes32 indexed commandId,
        string sourceChain,
        string sourceAddress,
        address indexed contractAddress,
        bytes32 indexed payloadHash,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    );

    event ContractCallApprovedWithMint(
        bytes32 indexed commandId,
        string sourceChain,
        string sourceAddress,
        address indexed contractAddress,
        bytes32 indexed payloadHash,
        string symbol,
        uint256 amount,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    );

    event TokenMintLimitUpdated(string symbol, uint256 limit);

    event OperatorshipTransferred(bytes newOperatorsData);

    event Upgraded(address indexed implementation);

    /********************\
    |* Public Functions *|
    \********************/

    function sendToken(
        string calldata destinationChain,
        string calldata destinationAddress,
        string calldata symbol,
        uint256 amount
    ) external;

    function callContract(
        string calldata destinationChain,
        string calldata contractAddress,
        bytes calldata payload
    ) external;

    function callContractWithToken(
        string calldata destinationChain,
        string calldata contractAddress,
        bytes calldata payload,
        string calldata symbol,
        uint256 amount
    ) external;

    function isContractCallApproved(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) external view returns (bool);

    function isContractCallAndMintApproved(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string calldata symbol,
        uint256 amount
    ) external view returns (bool);

    function validateContractCall(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes32 payloadHash
    ) external returns (bool);

    function validateContractCallAndMint(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes32 payloadHash,
        string calldata symbol,
        uint256 amount
    ) external returns (bool);

    /***********\
    |* Getters *|
    \***********/

    function authModule() external view returns (address);

    function tokenDeployer() external view returns (address);

    function tokenMintLimit(string memory symbol) external view returns (uint256);

    function tokenMintAmount(string memory symbol) external view returns (uint256);

    function allTokensFrozen() external view returns (bool);

    function implementation() external view returns (address);

    function tokenAddresses(string memory symbol) external view returns (address);

    function tokenFrozen(string memory symbol) external view returns (bool);

    function isCommandExecuted(bytes32 commandId) external view returns (bool);

    function adminEpoch() external view returns (uint256);

    function adminThreshold(uint256 epoch) external view returns (uint256);

    function admins(uint256 epoch) external view returns (address[] memory);

    /*******************\
    |* Admin Functions *|
    \*******************/

    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external;

    function upgrade(
        address newImplementation,
        bytes32 newImplementationCodeHash,
        bytes calldata setupParams
    ) external;

    /**********************\
    |* External Functions *|
    \**********************/

    function setup(bytes calldata params) external;

    function execute(bytes calldata input) external;
}

// File contracts/interfaces/IAxelarExecutable.sol

interface IAxelarExecutable {
    error InvalidAddress();
    error NotApprovedByGateway();

    function gateway() external view returns (IAxelarGateway);

    function execute(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes calldata payload
    ) external;

    function executeWithToken(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes calldata payload,
        string calldata tokenSymbol,
        uint256 amount
    ) external;
}

// File contracts/interfaces/IBaseMultisig.sol

/**
 * @title IMultisigBase Interface
 * @notice An interface defining the base operations for a multi-signature contract.
 */
interface IBaseMultisig {
    error NotSigner();
    error AlreadyVoted();
    error InvalidSigners();
    error InvalidSignerThreshold();
    error DuplicateSigner(address account);

    /**********\
    |* Events *|
    \**********/

    event MultisigOperationExecuted(bytes32 indexed operationHash);

    event SignersRotated(address[] newAccounts, uint256 newThreshold);

    /***********\
    |* Getters *|
    \***********/

    /**
     * @notice Gets the current epoch.
     * @return uint The current epoch
     */
    function signerEpoch() external view returns (uint256);

    /**
     * @notice Gets the threshold of current signers.
     * @return uint The threshold number
     */
    function signerThreshold() external view returns (uint256);

    /**
     * @notice Gets the array of current signers.
     * @return array of signer addresses
     */
    function signerAccounts() external view returns (address[] memory);

    /**
     * @notice Getter to determine if an account is a signer
     * @return boolean indicating if the account is a signer
     */
    function isSigner(address account) external view returns (bool);

    /**
     * @notice Getter to determine if an account has voted on a topic
     * @return boolean indicating if the account has voted
     */
    function hasSignerVoted(address account, bytes32 topic) external view returns (bool);

    /**
     * @notice Get the number of votes for a topic
     * @return uint256 indicating the number of votes for a topic
     */
    function getSignerVotesCount(bytes32 topic) external view returns (uint256);

    /***********\
    |* Setters *|
    \***********/

    /**
     * @notice Update the signers and threshold for the multisig contract.
     * @param newAccounts The array of new signers
     * @param newThreshold The new threshold of signers required
     */
    function rotateSigners(address[] memory newAccounts, uint256 newThreshold) external;
}

// File contracts/interfaces/ICaller.sol

interface ICaller {
    error InvalidContract(address target);
    error InsufficientBalance();
    error ExecutionFailed();
}

// File contracts/interfaces/IInterchainGovernance.sol

/**
 * @title IInterchainGovernance Interface
 * @notice This interface extends IAxelarExecutable for interchain governance mechanisms.
 */
interface IInterchainGovernance is IAxelarExecutable, ICaller {
    error NotGovernance();
    error NotSelf();
    error InvalidCommand();
    error InvalidTarget();
    error TokenNotSupported();

    event ProposalScheduled(
        bytes32 indexed proposalHash,
        address indexed target,
        bytes callData,
        uint256 value,
        uint256 indexed eta
    );
    event ProposalCancelled(
        bytes32 indexed proposalHash,
        address indexed target,
        bytes callData,
        uint256 value,
        uint256 indexed eta
    );
    event ProposalExecuted(
        bytes32 indexed proposalHash,
        address indexed target,
        bytes callData,
        uint256 value,
        uint256 indexed timestamp
    );

    /**
     * @notice Returns the name of the governance chain.
     * @return string The name of the governance chain
     */
    function governanceChain() external view returns (string memory);

    /**
     * @notice Returns the address of the governance address.
     * @return string The address of the governance address
     */
    function governanceAddress() external view returns (string memory);

    /**
     * @notice Returns the hash of the governance chain.
     * @return bytes32 The hash of the governance chain
     */
    function governanceChainHash() external view returns (bytes32);

    /**
     * @notice Returns the hash of the governance address.
     * @return bytes32 The hash of the governance address
     */
    function governanceAddressHash() external view returns (bytes32);

    /**
     * @notice Returns the ETA of a proposal.
     * @param target The address of the contract targeted by the proposal
     * @param callData The call data to be sent to the target contract
     * @param nativeValue The amount of native tokens to be sent to the target contract
     * @return uint256 The ETA of the proposal
     */
    function getProposalEta(
        address target,
        bytes calldata callData,
        uint256 nativeValue
    ) external view returns (uint256);

    /**
     * @notice Executes a governance proposal.
     * @param targetContract The address of the contract targeted by the proposal
     * @param callData The call data to be sent to the target contract
     * @param value The amount of ETH to be sent to the target contract
     */
    function executeProposal(
        address targetContract,
        bytes calldata callData,
        uint256 value
    ) external payable;

    /**
     * @notice Withdraws native token from the contract
     * @param recipient The address to send the native token to
     * @param amount The amount of native token to send
     * @dev This function is only callable by the contract itself after passing according proposal
     */
    function withdraw(address recipient, uint256 amount) external;
}

// File contracts/interfaces/IAxelarServiceGovernance.sol

/**
 * @title IAxelarServiceGovernance Interface
 * @dev This interface extends IInterchainGovernance and IMultisigBase for multisig proposal actions
 */
interface IAxelarServiceGovernance is IBaseMultisig, IInterchainGovernance {
    error NotApproved();

    event MultisigApproved(
        bytes32 indexed proposalHash,
        address indexed targetContract,
        bytes callData,
        uint256 nativeValue
    );
    event MultisigCancelled(
        bytes32 indexed proposalHash,
        address indexed targetContract,
        bytes callData,
        uint256 nativeValue
    );
    event MultisigExecuted(
        bytes32 indexed proposalHash,
        address indexed targetContract,
        bytes callData,
        uint256 nativeValue
    );

    /**
     * @notice Returns whether a multisig proposal has been approved
     * @param proposalHash The hash of the proposal
     * @return bool Whether the proposal has been approved
     */
    function multisigApprovals(bytes32 proposalHash) external view returns (bool);

    /**
     * @notice Executes a multisig proposal
     * @param targetContract The target address the proposal will call
     * @param callData The data that encodes the function and arguments to call on the target contract
     */
    function executeMultisigProposal(
        address targetContract,
        bytes calldata callData,
        uint256 value
    ) external payable;
}
