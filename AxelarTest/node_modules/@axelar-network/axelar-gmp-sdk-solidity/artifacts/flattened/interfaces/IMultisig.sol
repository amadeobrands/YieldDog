// Source: contracts/interfaces/IMultisig.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

// File contracts/interfaces/IBaseMultisig.sol

/**
 * @title IMultisigBase Interface
 * @notice An interface defining the base operations for a multi-signature contract.
 */
interface IBaseMultisig {
    error NotSigner();
    error AlreadyVoted();
    error InvalidSigners();
    error InvalidSignerThreshold();
    error DuplicateSigner(address account);

    /**********\
    |* Events *|
    \**********/

    event MultisigOperationExecuted(bytes32 indexed operationHash);

    event SignersRotated(address[] newAccounts, uint256 newThreshold);

    /***********\
    |* Getters *|
    \***********/

    /**
     * @notice Gets the current epoch.
     * @return uint The current epoch
     */
    function signerEpoch() external view returns (uint256);

    /**
     * @notice Gets the threshold of current signers.
     * @return uint The threshold number
     */
    function signerThreshold() external view returns (uint256);

    /**
     * @notice Gets the array of current signers.
     * @return array of signer addresses
     */
    function signerAccounts() external view returns (address[] memory);

    /**
     * @notice Getter to determine if an account is a signer
     * @return boolean indicating if the account is a signer
     */
    function isSigner(address account) external view returns (bool);

    /**
     * @notice Getter to determine if an account has voted on a topic
     * @return boolean indicating if the account has voted
     */
    function hasSignerVoted(address account, bytes32 topic) external view returns (bool);

    /**
     * @notice Get the number of votes for a topic
     * @return uint256 indicating the number of votes for a topic
     */
    function getSignerVotesCount(bytes32 topic) external view returns (uint256);

    /***********\
    |* Setters *|
    \***********/

    /**
     * @notice Update the signers and threshold for the multisig contract.
     * @param newAccounts The array of new signers
     * @param newThreshold The new threshold of signers required
     */
    function rotateSigners(address[] memory newAccounts, uint256 newThreshold) external;
}

// File contracts/interfaces/ICaller.sol

interface ICaller {
    error InvalidContract(address target);
    error InsufficientBalance();
    error ExecutionFailed();
}

// File contracts/interfaces/IContractExecutor.sol

/**
 * @title IContractExecutor Interface
 * @notice This interface defines the execute function used to interact with external contracts.
 */
interface IContractExecutor {
    /**
     * @notice Executes a call to an external contract.
     * @dev Execution logic is left up to the implementation.
     * @param target The address of the contract to be called
     * @param callData The calldata to be sent
     * @param nativeValue The amount of native token (e.g., Ether) to be sent along with the call
     * @return bytes The data returned from the executed call
     */
    function executeContract(
        address target,
        bytes calldata callData,
        uint256 nativeValue
    ) external payable returns (bytes memory);
}

// File contracts/interfaces/IMultisig.sol

/**
 * @title IMultisig Interface
 * @notice This interface extends IMultisigBase by adding an execute function for multisignature transactions.
 */
interface IMultisig is ICaller, IContractExecutor, IBaseMultisig {
    /**
     * @notice Withdraws native token from the contract
     * @param recipient The address to send the native token to
     * @param amount The amount of native token to send
     * @dev This function is only callable by the contract itself after passing according proposal
     */
    function withdraw(address recipient, uint256 amount) external;
}
