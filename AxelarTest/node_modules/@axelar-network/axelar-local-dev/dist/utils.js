'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setLogger = exports.httpGet = exports.setJSON = exports.deployContract = exports.defaultAccounts = exports.getNearLogID = exports.getEVMLogID = exports.getRandomID = exports.getSignedExecuteInput = exports.bigNumberToNumber = exports.logger = void 0;
const ethers_1 = require("ethers");
const fs_extra_1 = require("fs-extra");
const http_1 = __importDefault(require("http"));
const { defaultAbiCoder, id, arrayify, keccak256 } = ethers_1.ethers.utils;
exports.logger = { log: console.log };
const getRandomInt = (max) => {
    return Math.floor(Math.random() * max);
};
function bigNumberToNumber(bigNumber) {
    return bigNumber.toNumber();
}
exports.bigNumberToNumber = bigNumberToNumber;
function getSignedExecuteInput(data, wallet) {
    return __awaiter(this, void 0, void 0, function* () {
        const signature = yield wallet.signMessage(arrayify(keccak256(data)));
        const signData = defaultAbiCoder.encode(['address[]', 'uint256[]', 'uint256', 'bytes[]'], [[wallet.address], [1], 1, [signature]]);
        return defaultAbiCoder.encode(['bytes', 'bytes'], [data, signData]);
    });
}
exports.getSignedExecuteInput = getSignedExecuteInput;
const getRandomID = () => id(getRandomInt(1e10).toString());
exports.getRandomID = getRandomID;
const getEVMLogID = (chain, log) => {
    const txData = [chain, log.transactionHash, log.logIndex].join(':');
    return id(txData);
};
exports.getEVMLogID = getEVMLogID;
const getNearLogID = (chain, event) => {
    return id(chain + ':' + event.standard + ':' + event.version + ':' + new Date().getMilliseconds());
};
exports.getNearLogID = getNearLogID;
const defaultAccounts = (n, seed = '') => {
    const balance = BigInt(1e30);
    const privateKeys = [];
    let key = keccak256(defaultAbiCoder.encode(['string'], [seed]));
    for (let i = 0; i < n; i++) {
        privateKeys.push(key);
        key = keccak256(key);
    }
    return privateKeys.map((secretKey) => ({ balance, secretKey }));
};
exports.defaultAccounts = defaultAccounts;
const deployContract = (wallet, contractJson, args = [], options = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const factory = new ethers_1.ContractFactory(contractJson.abi, contractJson.bytecode, wallet);
    const contract = yield factory.deploy(...args, Object.assign({}, options));
    yield contract.deployed();
    return contract;
});
exports.deployContract = deployContract;
const setJSON = (data, name) => {
    (0, fs_extra_1.outputJsonSync)(name, data, {
        spaces: 2,
        EOL: '\n',
    });
};
exports.setJSON = setJSON;
const httpGet = (url) => {
    return new Promise((resolve, reject) => {
        http_1.default.get(url, (res) => {
            const { statusCode } = res;
            const contentType = res.headers['content-type'];
            let error;
            if (statusCode !== 200) {
                error = new Error('Request Failed.\n' + `Status Code: ${statusCode}`);
            }
            else if (!/^application\/json/.test(contentType)) {
                error = new Error('Invalid content-type.\n' + `Expected application/json but received ${contentType}`);
            }
            if (error) {
                res.resume();
                reject(error);
                return;
            }
            res.setEncoding('utf8');
            let rawData = '';
            res.on('data', (chunk) => {
                rawData += chunk;
            });
            res.on('end', () => {
                try {
                    const parsedData = JSON.parse(rawData);
                    resolve(parsedData);
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    });
};
exports.httpGet = httpGet;
function setLogger(log) {
    exports.logger.log = log;
}
exports.setLogger = setLogger;
//# sourceMappingURL=utils.js.map