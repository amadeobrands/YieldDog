import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from "../../../common";
export interface AxelarGatewayInterface extends utils.Interface {
    functions: {
        "adminEpoch()": FunctionFragment;
        "adminThreshold(uint256)": FunctionFragment;
        "admins(uint256)": FunctionFragment;
        "allTokensFrozen()": FunctionFragment;
        "approveContractCall(bytes,bytes32)": FunctionFragment;
        "approveContractCallWithMint(bytes,bytes32)": FunctionFragment;
        "authModule()": FunctionFragment;
        "burnToken(bytes,bytes32)": FunctionFragment;
        "callContract(string,string,bytes)": FunctionFragment;
        "callContractWithToken(string,string,bytes,string,uint256)": FunctionFragment;
        "contractId()": FunctionFragment;
        "deployToken(bytes,bytes32)": FunctionFragment;
        "execute(bytes)": FunctionFragment;
        "getAddress(bytes32)": FunctionFragment;
        "getBool(bytes32)": FunctionFragment;
        "getBytes(bytes32)": FunctionFragment;
        "getInt(bytes32)": FunctionFragment;
        "getString(bytes32)": FunctionFragment;
        "getUint(bytes32)": FunctionFragment;
        "governance()": FunctionFragment;
        "implementation()": FunctionFragment;
        "isCommandExecuted(bytes32)": FunctionFragment;
        "isContractCallAndMintApproved(bytes32,string,string,address,bytes32,string,uint256)": FunctionFragment;
        "isContractCallApproved(bytes32,string,string,address,bytes32)": FunctionFragment;
        "mintLimiter()": FunctionFragment;
        "mintToken(bytes,bytes32)": FunctionFragment;
        "sendToken(string,string,string,uint256)": FunctionFragment;
        "setTokenMintLimits(string[],uint256[])": FunctionFragment;
        "setup(bytes)": FunctionFragment;
        "tokenAddresses(string)": FunctionFragment;
        "tokenDeployer()": FunctionFragment;
        "tokenFrozen(string)": FunctionFragment;
        "tokenMintAmount(string)": FunctionFragment;
        "tokenMintLimit(string)": FunctionFragment;
        "transferGovernance(address)": FunctionFragment;
        "transferMintLimiter(address)": FunctionFragment;
        "transferOperatorship(bytes,bytes32)": FunctionFragment;
        "upgrade(address,bytes32,bytes)": FunctionFragment;
        "validateContractCall(bytes32,string,string,bytes32)": FunctionFragment;
        "validateContractCallAndMint(bytes32,string,string,bytes32,string,uint256)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "adminEpoch" | "adminThreshold" | "admins" | "allTokensFrozen" | "approveContractCall" | "approveContractCallWithMint" | "authModule" | "burnToken" | "callContract" | "callContractWithToken" | "contractId" | "deployToken" | "execute" | "getAddress" | "getBool" | "getBytes" | "getInt" | "getString" | "getUint" | "governance" | "implementation" | "isCommandExecuted" | "isContractCallAndMintApproved" | "isContractCallApproved" | "mintLimiter" | "mintToken" | "sendToken" | "setTokenMintLimits" | "setup" | "tokenAddresses" | "tokenDeployer" | "tokenFrozen" | "tokenMintAmount" | "tokenMintLimit" | "transferGovernance" | "transferMintLimiter" | "transferOperatorship" | "upgrade" | "validateContractCall" | "validateContractCallAndMint"): FunctionFragment;
    encodeFunctionData(functionFragment: "adminEpoch", values?: undefined): string;
    encodeFunctionData(functionFragment: "adminThreshold", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "admins", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "allTokensFrozen", values?: undefined): string;
    encodeFunctionData(functionFragment: "approveContractCall", values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "approveContractCallWithMint", values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "authModule", values?: undefined): string;
    encodeFunctionData(functionFragment: "burnToken", values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "callContract", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "callContractWithToken", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "contractId", values?: undefined): string;
    encodeFunctionData(functionFragment: "deployToken", values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "execute", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getAddress", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getBool", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getBytes", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getInt", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getString", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "getUint", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "governance", values?: undefined): string;
    encodeFunctionData(functionFragment: "implementation", values?: undefined): string;
    encodeFunctionData(functionFragment: "isCommandExecuted", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "isContractCallAndMintApproved", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "isContractCallApproved", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "mintLimiter", values?: undefined): string;
    encodeFunctionData(functionFragment: "mintToken", values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "sendToken", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "setTokenMintLimits", values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]]): string;
    encodeFunctionData(functionFragment: "setup", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "tokenAddresses", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "tokenDeployer", values?: undefined): string;
    encodeFunctionData(functionFragment: "tokenFrozen", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "tokenMintAmount", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "tokenMintLimit", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "transferGovernance", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "transferMintLimiter", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "transferOperatorship", values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "upgrade", values: [
        PromiseOrValue<string>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "validateContractCall", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "validateContractCallAndMint", values: [
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    decodeFunctionResult(functionFragment: "adminEpoch", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "adminThreshold", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "admins", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allTokensFrozen", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approveContractCall", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "approveContractCallWithMint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "authModule", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "burnToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "callContract", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "callContractWithToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "contractId", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "deployToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "execute", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getBool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getBytes", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getInt", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getString", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getUint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "governance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "implementation", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isCommandExecuted", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isContractCallAndMintApproved", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isContractCallApproved", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mintLimiter", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mintToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "sendToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setTokenMintLimits", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setup", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tokenAddresses", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tokenDeployer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tokenFrozen", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tokenMintAmount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tokenMintLimit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferGovernance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferMintLimiter", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferOperatorship", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "upgrade", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "validateContractCall", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "validateContractCallAndMint", data: BytesLike): Result;
    events: {
        "ContractCall(address,string,string,bytes32,bytes)": EventFragment;
        "ContractCallApproved(bytes32,string,string,address,bytes32,bytes32,uint256)": EventFragment;
        "ContractCallApprovedWithMint(bytes32,string,string,address,bytes32,string,uint256,bytes32,uint256)": EventFragment;
        "ContractCallWithToken(address,string,string,bytes32,bytes,string,uint256)": EventFragment;
        "Executed(bytes32)": EventFragment;
        "GovernanceTransferred(address,address)": EventFragment;
        "MintLimiterTransferred(address,address)": EventFragment;
        "OperatorshipTransferred(bytes)": EventFragment;
        "TokenDeployed(string,address)": EventFragment;
        "TokenMintLimitUpdated(string,uint256)": EventFragment;
        "TokenSent(address,string,string,string,uint256)": EventFragment;
        "Upgraded(address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "ContractCall"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ContractCallApproved"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ContractCallApprovedWithMint"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ContractCallWithToken"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Executed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "GovernanceTransferred"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "MintLimiterTransferred"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OperatorshipTransferred"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TokenDeployed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TokenMintLimitUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TokenSent"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Upgraded"): EventFragment;
}
export interface ContractCallEventObject {
    sender: string;
    destinationChain: string;
    destinationContractAddress: string;
    payloadHash: string;
    payload: string;
}
export type ContractCallEvent = TypedEvent<[
    string,
    string,
    string,
    string,
    string
], ContractCallEventObject>;
export type ContractCallEventFilter = TypedEventFilter<ContractCallEvent>;
export interface ContractCallApprovedEventObject {
    commandId: string;
    sourceChain: string;
    sourceAddress: string;
    contractAddress: string;
    payloadHash: string;
    sourceTxHash: string;
    sourceEventIndex: BigNumber;
}
export type ContractCallApprovedEvent = TypedEvent<[
    string,
    string,
    string,
    string,
    string,
    string,
    BigNumber
], ContractCallApprovedEventObject>;
export type ContractCallApprovedEventFilter = TypedEventFilter<ContractCallApprovedEvent>;
export interface ContractCallApprovedWithMintEventObject {
    commandId: string;
    sourceChain: string;
    sourceAddress: string;
    contractAddress: string;
    payloadHash: string;
    symbol: string;
    amount: BigNumber;
    sourceTxHash: string;
    sourceEventIndex: BigNumber;
}
export type ContractCallApprovedWithMintEvent = TypedEvent<[
    string,
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    string,
    BigNumber
], ContractCallApprovedWithMintEventObject>;
export type ContractCallApprovedWithMintEventFilter = TypedEventFilter<ContractCallApprovedWithMintEvent>;
export interface ContractCallWithTokenEventObject {
    sender: string;
    destinationChain: string;
    destinationContractAddress: string;
    payloadHash: string;
    payload: string;
    symbol: string;
    amount: BigNumber;
}
export type ContractCallWithTokenEvent = TypedEvent<[
    string,
    string,
    string,
    string,
    string,
    string,
    BigNumber
], ContractCallWithTokenEventObject>;
export type ContractCallWithTokenEventFilter = TypedEventFilter<ContractCallWithTokenEvent>;
export interface ExecutedEventObject {
    commandId: string;
}
export type ExecutedEvent = TypedEvent<[string], ExecutedEventObject>;
export type ExecutedEventFilter = TypedEventFilter<ExecutedEvent>;
export interface GovernanceTransferredEventObject {
    previousGovernance: string;
    newGovernance: string;
}
export type GovernanceTransferredEvent = TypedEvent<[
    string,
    string
], GovernanceTransferredEventObject>;
export type GovernanceTransferredEventFilter = TypedEventFilter<GovernanceTransferredEvent>;
export interface MintLimiterTransferredEventObject {
    previousGovernance: string;
    newGovernance: string;
}
export type MintLimiterTransferredEvent = TypedEvent<[
    string,
    string
], MintLimiterTransferredEventObject>;
export type MintLimiterTransferredEventFilter = TypedEventFilter<MintLimiterTransferredEvent>;
export interface OperatorshipTransferredEventObject {
    newOperatorsData: string;
}
export type OperatorshipTransferredEvent = TypedEvent<[
    string
], OperatorshipTransferredEventObject>;
export type OperatorshipTransferredEventFilter = TypedEventFilter<OperatorshipTransferredEvent>;
export interface TokenDeployedEventObject {
    symbol: string;
    tokenAddresses: string;
}
export type TokenDeployedEvent = TypedEvent<[
    string,
    string
], TokenDeployedEventObject>;
export type TokenDeployedEventFilter = TypedEventFilter<TokenDeployedEvent>;
export interface TokenMintLimitUpdatedEventObject {
    symbol: string;
    limit: BigNumber;
}
export type TokenMintLimitUpdatedEvent = TypedEvent<[
    string,
    BigNumber
], TokenMintLimitUpdatedEventObject>;
export type TokenMintLimitUpdatedEventFilter = TypedEventFilter<TokenMintLimitUpdatedEvent>;
export interface TokenSentEventObject {
    sender: string;
    destinationChain: string;
    destinationAddress: string;
    symbol: string;
    amount: BigNumber;
}
export type TokenSentEvent = TypedEvent<[
    string,
    string,
    string,
    string,
    BigNumber
], TokenSentEventObject>;
export type TokenSentEventFilter = TypedEventFilter<TokenSentEvent>;
export interface UpgradedEventObject {
    implementation: string;
}
export type UpgradedEvent = TypedEvent<[string], UpgradedEventObject>;
export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;
export interface AxelarGateway extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: AxelarGatewayInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        adminEpoch(overrides?: CallOverrides): Promise<[BigNumber]>;
        adminThreshold(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;
        admins(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string[]]>;
        allTokensFrozen(overrides?: CallOverrides): Promise<[boolean]>;
        approveContractCall(params: PromiseOrValue<BytesLike>, commandId: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        approveContractCallWithMint(params: PromiseOrValue<BytesLike>, commandId: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        authModule(overrides?: CallOverrides): Promise<[string]>;
        burnToken(params: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        callContract(destinationChain: PromiseOrValue<string>, destinationContractAddress: PromiseOrValue<string>, payload: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        callContractWithToken(destinationChain: PromiseOrValue<string>, destinationContractAddress: PromiseOrValue<string>, payload: PromiseOrValue<BytesLike>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        contractId(overrides?: CallOverrides): Promise<[string]>;
        deployToken(params: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        execute(input: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getAddress(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getBool(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[boolean]>;
        getBytes(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getInt(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber]>;
        getString(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;
        getUint(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber]>;
        governance(overrides?: CallOverrides): Promise<[string]>;
        implementation(overrides?: CallOverrides): Promise<[string]>;
        isCommandExecuted(commandId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[boolean]>;
        isContractCallAndMintApproved(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, contractAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[boolean]>;
        isContractCallApproved(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, contractAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[boolean]>;
        mintLimiter(overrides?: CallOverrides): Promise<[string]>;
        mintToken(params: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        sendToken(destinationChain: PromiseOrValue<string>, destinationAddress: PromiseOrValue<string>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setTokenMintLimits(symbols: PromiseOrValue<string>[], limits: PromiseOrValue<BigNumberish>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        setup(params: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        tokenAddresses(symbol: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;
        tokenDeployer(overrides?: CallOverrides): Promise<[string]>;
        tokenFrozen(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        tokenMintAmount(symbol: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
        tokenMintLimit(symbol: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
        transferGovernance(newGovernance: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferMintLimiter(newMintLimiter: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferOperatorship(newOperatorsData: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        upgrade(newImplementation: PromiseOrValue<string>, newImplementationCodeHash: PromiseOrValue<BytesLike>, setupParams: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        validateContractCall(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        validateContractCallAndMint(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    adminEpoch(overrides?: CallOverrides): Promise<BigNumber>;
    adminThreshold(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
    admins(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string[]>;
    allTokensFrozen(overrides?: CallOverrides): Promise<boolean>;
    approveContractCall(params: PromiseOrValue<BytesLike>, commandId: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    approveContractCallWithMint(params: PromiseOrValue<BytesLike>, commandId: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    authModule(overrides?: CallOverrides): Promise<string>;
    burnToken(params: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callContract(destinationChain: PromiseOrValue<string>, destinationContractAddress: PromiseOrValue<string>, payload: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callContractWithToken(destinationChain: PromiseOrValue<string>, destinationContractAddress: PromiseOrValue<string>, payload: PromiseOrValue<BytesLike>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    contractId(overrides?: CallOverrides): Promise<string>;
    deployToken(params: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    execute(input: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getAddress(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getBool(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;
    getBytes(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getInt(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
    getString(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    getUint(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
    governance(overrides?: CallOverrides): Promise<string>;
    implementation(overrides?: CallOverrides): Promise<string>;
    isCommandExecuted(commandId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;
    isContractCallAndMintApproved(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, contractAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;
    isContractCallApproved(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, contractAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;
    mintLimiter(overrides?: CallOverrides): Promise<string>;
    mintToken(params: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    sendToken(destinationChain: PromiseOrValue<string>, destinationAddress: PromiseOrValue<string>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setTokenMintLimits(symbols: PromiseOrValue<string>[], limits: PromiseOrValue<BigNumberish>[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    setup(params: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    tokenAddresses(symbol: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;
    tokenDeployer(overrides?: CallOverrides): Promise<string>;
    tokenFrozen(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    tokenMintAmount(symbol: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    tokenMintLimit(symbol: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    transferGovernance(newGovernance: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferMintLimiter(newMintLimiter: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferOperatorship(newOperatorsData: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    upgrade(newImplementation: PromiseOrValue<string>, newImplementationCodeHash: PromiseOrValue<BytesLike>, setupParams: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    validateContractCall(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    validateContractCallAndMint(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        adminEpoch(overrides?: CallOverrides): Promise<BigNumber>;
        adminThreshold(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        admins(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string[]>;
        allTokensFrozen(overrides?: CallOverrides): Promise<boolean>;
        approveContractCall(params: PromiseOrValue<BytesLike>, commandId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        approveContractCallWithMint(params: PromiseOrValue<BytesLike>, commandId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        authModule(overrides?: CallOverrides): Promise<string>;
        burnToken(params: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        callContract(destinationChain: PromiseOrValue<string>, destinationContractAddress: PromiseOrValue<string>, payload: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        callContractWithToken(destinationChain: PromiseOrValue<string>, destinationContractAddress: PromiseOrValue<string>, payload: PromiseOrValue<BytesLike>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        contractId(overrides?: CallOverrides): Promise<string>;
        deployToken(params: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        execute(input: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        getAddress(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getBool(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;
        getBytes(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getInt(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        getString(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
        getUint(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        governance(overrides?: CallOverrides): Promise<string>;
        implementation(overrides?: CallOverrides): Promise<string>;
        isCommandExecuted(commandId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;
        isContractCallAndMintApproved(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, contractAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;
        isContractCallApproved(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, contractAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;
        mintLimiter(overrides?: CallOverrides): Promise<string>;
        mintToken(params: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        sendToken(destinationChain: PromiseOrValue<string>, destinationAddress: PromiseOrValue<string>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        setTokenMintLimits(symbols: PromiseOrValue<string>[], limits: PromiseOrValue<BigNumberish>[], overrides?: CallOverrides): Promise<void>;
        setup(params: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        tokenAddresses(symbol: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;
        tokenDeployer(overrides?: CallOverrides): Promise<string>;
        tokenFrozen(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        tokenMintAmount(symbol: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        tokenMintLimit(symbol: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        transferGovernance(newGovernance: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        transferMintLimiter(newMintLimiter: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        transferOperatorship(newOperatorsData: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        upgrade(newImplementation: PromiseOrValue<string>, newImplementationCodeHash: PromiseOrValue<BytesLike>, setupParams: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        validateContractCall(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;
        validateContractCallAndMint(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;
    };
    filters: {
        "ContractCall(address,string,string,bytes32,bytes)"(sender?: PromiseOrValue<string> | null, destinationChain?: null, destinationContractAddress?: null, payloadHash?: PromiseOrValue<BytesLike> | null, payload?: null): ContractCallEventFilter;
        ContractCall(sender?: PromiseOrValue<string> | null, destinationChain?: null, destinationContractAddress?: null, payloadHash?: PromiseOrValue<BytesLike> | null, payload?: null): ContractCallEventFilter;
        "ContractCallApproved(bytes32,string,string,address,bytes32,bytes32,uint256)"(commandId?: PromiseOrValue<BytesLike> | null, sourceChain?: null, sourceAddress?: null, contractAddress?: PromiseOrValue<string> | null, payloadHash?: PromiseOrValue<BytesLike> | null, sourceTxHash?: null, sourceEventIndex?: null): ContractCallApprovedEventFilter;
        ContractCallApproved(commandId?: PromiseOrValue<BytesLike> | null, sourceChain?: null, sourceAddress?: null, contractAddress?: PromiseOrValue<string> | null, payloadHash?: PromiseOrValue<BytesLike> | null, sourceTxHash?: null, sourceEventIndex?: null): ContractCallApprovedEventFilter;
        "ContractCallApprovedWithMint(bytes32,string,string,address,bytes32,string,uint256,bytes32,uint256)"(commandId?: PromiseOrValue<BytesLike> | null, sourceChain?: null, sourceAddress?: null, contractAddress?: PromiseOrValue<string> | null, payloadHash?: PromiseOrValue<BytesLike> | null, symbol?: null, amount?: null, sourceTxHash?: null, sourceEventIndex?: null): ContractCallApprovedWithMintEventFilter;
        ContractCallApprovedWithMint(commandId?: PromiseOrValue<BytesLike> | null, sourceChain?: null, sourceAddress?: null, contractAddress?: PromiseOrValue<string> | null, payloadHash?: PromiseOrValue<BytesLike> | null, symbol?: null, amount?: null, sourceTxHash?: null, sourceEventIndex?: null): ContractCallApprovedWithMintEventFilter;
        "ContractCallWithToken(address,string,string,bytes32,bytes,string,uint256)"(sender?: PromiseOrValue<string> | null, destinationChain?: null, destinationContractAddress?: null, payloadHash?: PromiseOrValue<BytesLike> | null, payload?: null, symbol?: null, amount?: null): ContractCallWithTokenEventFilter;
        ContractCallWithToken(sender?: PromiseOrValue<string> | null, destinationChain?: null, destinationContractAddress?: null, payloadHash?: PromiseOrValue<BytesLike> | null, payload?: null, symbol?: null, amount?: null): ContractCallWithTokenEventFilter;
        "Executed(bytes32)"(commandId?: PromiseOrValue<BytesLike> | null): ExecutedEventFilter;
        Executed(commandId?: PromiseOrValue<BytesLike> | null): ExecutedEventFilter;
        "GovernanceTransferred(address,address)"(previousGovernance?: PromiseOrValue<string> | null, newGovernance?: PromiseOrValue<string> | null): GovernanceTransferredEventFilter;
        GovernanceTransferred(previousGovernance?: PromiseOrValue<string> | null, newGovernance?: PromiseOrValue<string> | null): GovernanceTransferredEventFilter;
        "MintLimiterTransferred(address,address)"(previousGovernance?: PromiseOrValue<string> | null, newGovernance?: PromiseOrValue<string> | null): MintLimiterTransferredEventFilter;
        MintLimiterTransferred(previousGovernance?: PromiseOrValue<string> | null, newGovernance?: PromiseOrValue<string> | null): MintLimiterTransferredEventFilter;
        "OperatorshipTransferred(bytes)"(newOperatorsData?: null): OperatorshipTransferredEventFilter;
        OperatorshipTransferred(newOperatorsData?: null): OperatorshipTransferredEventFilter;
        "TokenDeployed(string,address)"(symbol?: null, tokenAddresses?: null): TokenDeployedEventFilter;
        TokenDeployed(symbol?: null, tokenAddresses?: null): TokenDeployedEventFilter;
        "TokenMintLimitUpdated(string,uint256)"(symbol?: null, limit?: null): TokenMintLimitUpdatedEventFilter;
        TokenMintLimitUpdated(symbol?: null, limit?: null): TokenMintLimitUpdatedEventFilter;
        "TokenSent(address,string,string,string,uint256)"(sender?: PromiseOrValue<string> | null, destinationChain?: null, destinationAddress?: null, symbol?: null, amount?: null): TokenSentEventFilter;
        TokenSent(sender?: PromiseOrValue<string> | null, destinationChain?: null, destinationAddress?: null, symbol?: null, amount?: null): TokenSentEventFilter;
        "Upgraded(address)"(implementation?: PromiseOrValue<string> | null): UpgradedEventFilter;
        Upgraded(implementation?: PromiseOrValue<string> | null): UpgradedEventFilter;
    };
    estimateGas: {
        adminEpoch(overrides?: CallOverrides): Promise<BigNumber>;
        adminThreshold(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        admins(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        allTokensFrozen(overrides?: CallOverrides): Promise<BigNumber>;
        approveContractCall(params: PromiseOrValue<BytesLike>, commandId: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        approveContractCallWithMint(params: PromiseOrValue<BytesLike>, commandId: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        authModule(overrides?: CallOverrides): Promise<BigNumber>;
        burnToken(params: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        callContract(destinationChain: PromiseOrValue<string>, destinationContractAddress: PromiseOrValue<string>, payload: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        callContractWithToken(destinationChain: PromiseOrValue<string>, destinationContractAddress: PromiseOrValue<string>, payload: PromiseOrValue<BytesLike>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        contractId(overrides?: CallOverrides): Promise<BigNumber>;
        deployToken(params: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        execute(input: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        getAddress(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        getBool(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        getBytes(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        getInt(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        getString(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        getUint(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        governance(overrides?: CallOverrides): Promise<BigNumber>;
        implementation(overrides?: CallOverrides): Promise<BigNumber>;
        isCommandExecuted(commandId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        isContractCallAndMintApproved(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, contractAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        isContractCallApproved(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, contractAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        mintLimiter(overrides?: CallOverrides): Promise<BigNumber>;
        mintToken(params: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        sendToken(destinationChain: PromiseOrValue<string>, destinationAddress: PromiseOrValue<string>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setTokenMintLimits(symbols: PromiseOrValue<string>[], limits: PromiseOrValue<BigNumberish>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        setup(params: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        tokenAddresses(symbol: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        tokenDeployer(overrides?: CallOverrides): Promise<BigNumber>;
        tokenFrozen(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        tokenMintAmount(symbol: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        tokenMintLimit(symbol: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        transferGovernance(newGovernance: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        transferMintLimiter(newMintLimiter: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        transferOperatorship(newOperatorsData: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        upgrade(newImplementation: PromiseOrValue<string>, newImplementationCodeHash: PromiseOrValue<BytesLike>, setupParams: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        validateContractCall(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        validateContractCallAndMint(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        adminEpoch(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        adminThreshold(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        admins(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        allTokensFrozen(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        approveContractCall(params: PromiseOrValue<BytesLike>, commandId: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        approveContractCallWithMint(params: PromiseOrValue<BytesLike>, commandId: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        authModule(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        burnToken(params: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        callContract(destinationChain: PromiseOrValue<string>, destinationContractAddress: PromiseOrValue<string>, payload: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        callContractWithToken(destinationChain: PromiseOrValue<string>, destinationContractAddress: PromiseOrValue<string>, payload: PromiseOrValue<BytesLike>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        contractId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        deployToken(params: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        execute(input: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getAddress(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getBool(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getBytes(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getInt(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getString(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getUint(key: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        governance(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        implementation(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isCommandExecuted(commandId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isContractCallAndMintApproved(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, contractAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isContractCallApproved(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, contractAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        mintLimiter(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        mintToken(params: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        sendToken(destinationChain: PromiseOrValue<string>, destinationAddress: PromiseOrValue<string>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setTokenMintLimits(symbols: PromiseOrValue<string>[], limits: PromiseOrValue<BigNumberish>[], overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        setup(params: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        tokenAddresses(symbol: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        tokenDeployer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        tokenFrozen(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        tokenMintAmount(symbol: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        tokenMintLimit(symbol: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        transferGovernance(newGovernance: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferMintLimiter(newMintLimiter: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferOperatorship(newOperatorsData: PromiseOrValue<BytesLike>, arg1: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        upgrade(newImplementation: PromiseOrValue<string>, newImplementationCodeHash: PromiseOrValue<BytesLike>, setupParams: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        validateContractCall(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        validateContractCallAndMint(commandId: PromiseOrValue<BytesLike>, sourceChain: PromiseOrValue<string>, sourceAddress: PromiseOrValue<string>, payloadHash: PromiseOrValue<BytesLike>, symbol: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}
//# sourceMappingURL=AxelarGateway.d.ts.map