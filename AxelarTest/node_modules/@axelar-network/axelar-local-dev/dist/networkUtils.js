'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDepositAddress = exports.depositAddresses = exports.stopAll = exports.stop = exports.forkNetwork = exports.setupNetwork = exports.getAllNetworks = exports.getNetwork = exports.createNetwork = exports.listen = exports.getGasPrice = exports.getFee = void 0;
const server_1 = __importDefault(require("./server"));
const ganache_1 = __importDefault(require("ganache"));
const fs_1 = __importDefault(require("fs"));
const ethers_1 = require("ethers");
const lodash_1 = require("lodash");
const utils_1 = require("./utils");
const Network_1 = require("./Network");
const AxelarGateway__factory_1 = require("./types/factories/@axelar-network/axelar-cgp-solidity/contracts/AxelarGateway__factory");
const AxelarGasService__factory_1 = require("./types/factories/@axelar-network/axelar-cgp-solidity/contracts/gas-service/AxelarGasService__factory");
const contracts_1 = require("./contracts");
const { keccak256, id, solidityPack, toUtf8Bytes } = ethers_1.ethers.utils;
let serverInstance;
const getFee = () => {
    return 1e6;
};
exports.getFee = getFee;
const getGasPrice = () => {
    return 1;
};
exports.getGasPrice = getGasPrice;
function listen(port, callback = undefined) {
    if (!callback)
        callback = () => {
            utils_1.logger.log(`Serving ${Network_1.networks.length} networks on port ${port}`);
        };
    serverInstance = (0, server_1.default)(Network_1.networks);
    return serverInstance.listen(port, callback);
}
exports.listen = listen;
function createNetwork(options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (options.dbPath && fs_1.default.existsSync(options.dbPath + '/networkInfo.json')) {
            const info = require(options.dbPath + '/networkInfo.json');
            const ganacheOptions = Object.assign(Object.assign({ database: { dbPath: options.dbPath } }, options.ganacheOptions), { chain: {
                    vmErrorsOnRPCResponse: true,
                    chainId: info.chainId,
                    networkId: info.chainId,
                }, logging: { quiet: true } });
            (0, lodash_1.merge)(ganacheOptions, options.ganacheOptions);
            const ganacheProvider = ganache_1.default.provider(ganacheOptions);
            const chain = yield getNetwork(new ethers_1.providers.Web3Provider(ganacheProvider), info);
            chain.ganacheProvider = ganacheProvider;
            if (options.port) {
                chain.port = options.port;
                chain.server = (0, server_1.default)(chain).listen(chain.port, () => {
                    utils_1.logger.log(`Serving ${chain.name} on port ${chain.port}`);
                });
            }
            return chain;
        }
        const chain = new Network_1.Network();
        chain.name = options.name != null ? options.name : `Chain ${Network_1.networks.length + 1}`;
        chain.chainId = options.chainId || Network_1.networks.length + 2500;
        utils_1.logger.log(`Creating ${chain.name} with a chainId of ${chain.chainId}...`);
        const accounts = (0, utils_1.defaultAccounts)(20, options.seed);
        const ganacheOptions = {
            database: { dbPath: options.dbPath },
            wallet: {
                accounts: accounts,
            },
            chain: {
                chainId: chain.chainId,
                networkId: chain.chainId,
                vmErrorsOnRPCResponse: true,
            },
            logging: { quiet: true },
        };
        (0, lodash_1.merge)(ganacheOptions, options.ganacheOptions);
        chain.ganacheProvider = ganache_1.default.provider(ganacheOptions);
        chain.provider = new ethers_1.providers.Web3Provider(chain.ganacheProvider);
        const wallets = accounts.map((x) => new ethers_1.Wallet(x.secretKey, chain.provider));
        chain.userWallets = wallets.splice(10, 20);
        [chain.ownerWallet, chain.operatorWallet, chain.relayerWallet] = wallets;
        chain.adminWallets = wallets.splice(4, 10);
        chain.threshold = 3;
        chain.lastRelayedBlock = yield chain.provider.getBlockNumber();
        chain.lastExpressedBlock = chain.lastRelayedBlock;
        yield chain.deployConstAddressDeployer();
        yield chain.deployCreate3Deployer();
        yield chain.deployGateway();
        yield chain.deployGasReceiver();
        chain.tokens = {};
        //chain.usdc = await chain.deployToken('Axelar Wrapped aUSDC', 'aUSDC', 6, BigInt(1e70));
        if (options.port) {
            chain.port = options.port;
            chain.server = (0, server_1.default)(chain).listen(chain.port, () => {
                utils_1.logger.log(`Serving ${chain.name} on port ${chain.port}`);
            });
        }
        if (options.dbPath) {
            (0, utils_1.setJSON)(chain.getInfo(), options.dbPath + '/networkInfo.json');
        }
        Network_1.networks.push(chain);
        return chain;
    });
}
exports.createNetwork = createNetwork;
function getNetwork(urlOrProvider, info = undefined) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!info)
            info = (yield (0, utils_1.httpGet)(urlOrProvider + '/info'));
        const chain = new Network_1.Network();
        chain.name = info.name;
        chain.chainId = info.chainId;
        utils_1.logger.log(`It is ${chain.name} and has a chainId of ${chain.chainId}...`);
        if (typeof urlOrProvider == 'string') {
            chain.provider = ethers_1.ethers.getDefaultProvider(urlOrProvider);
            chain.isRemote = true;
            chain.url = urlOrProvider;
        }
        else {
            chain.provider = urlOrProvider;
        }
        chain.userWallets = info.userKeys.map((x) => new ethers_1.Wallet(x, chain.provider));
        chain.ownerWallet = new ethers_1.Wallet(info.ownerKey, chain.provider);
        chain.operatorWallet = new ethers_1.Wallet(info.operatorKey, chain.provider);
        chain.relayerWallet = new ethers_1.Wallet(info.relayerKey, chain.provider);
        chain.adminWallets = info.adminKeys.map((x) => new ethers_1.Wallet(x, chain.provider));
        chain.threshold = info.threshold;
        chain.lastRelayedBlock = info.lastRelayedBlock;
        chain.lastExpressedBlock = info.lastExpressedBlock;
        chain.tokens = info.tokens;
        chain.constAddressDeployer = new ethers_1.Contract(info.constAddressDeployerAddress, contracts_1.ConstAddressDeployer.abi, chain.provider);
        chain.create3Deployer = new ethers_1.Contract(info.create3DeployerAddress, contracts_1.Create3Deployer.abi, chain.provider);
        chain.gateway = AxelarGateway__factory_1.AxelarGateway__factory.connect(info.gatewayAddress, chain.provider);
        chain.gasService = AxelarGasService__factory_1.AxelarGasService__factory.connect(info.gasReceiverAddress, chain.provider);
        //chain.usdc = await chain.getTokenContract('aUSDC');
        utils_1.logger.log(`Its gateway is deployed at ${chain.gateway.address}.`);
        Network_1.networks.push(chain);
        return chain;
    });
}
exports.getNetwork = getNetwork;
/**
 * @returns {[Network]}
 */
function getAllNetworks(url) {
    return __awaiter(this, void 0, void 0, function* () {
        const n = parseInt((yield (0, utils_1.httpGet)(url + '/info')));
        for (let i = 0; i < n; i++) {
            yield getNetwork(url + '/' + i);
        }
        return Network_1.networks;
    });
}
exports.getAllNetworks = getAllNetworks;
/**
 * @returns {Network}
 */
function setupNetwork(urlOrProvider, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const chain = new Network_1.Network();
        chain.name = options.name != null ? options.name : `Chain ${Network_1.networks.length + 1}`;
        chain.provider = typeof urlOrProvider === 'string' ? ethers_1.ethers.getDefaultProvider(urlOrProvider) : urlOrProvider;
        chain.chainId = (yield chain.provider.getNetwork()).chainId;
        utils_1.logger.log(`Setting up ${chain.name} on a network with a chainId of ${chain.chainId}...`);
        if (options.userKeys == null)
            options.userKeys = [];
        if (options.operatorKey == null)
            options.operatorKey = options.ownerKey;
        if (options.relayerKey == null)
            options.relayerKey = options.ownerKey;
        if (options.adminKeys == null)
            options.adminKeys = [options.ownerKey];
        chain.userWallets = options.userKeys.map((x) => new ethers_1.Wallet(x, chain.provider));
        chain.ownerWallet = new ethers_1.Wallet(options.ownerKey, chain.provider);
        chain.operatorWallet = new ethers_1.Wallet(options.operatorKey, chain.provider);
        chain.relayerWallet = new ethers_1.Wallet(options.relayerKey, chain.provider);
        chain.adminWallets = options.adminKeys.map((x) => new ethers_1.Wallet(x, chain.provider));
        chain.threshold = options.threshold != null ? options.threshold : 1;
        chain.lastRelayedBlock = yield chain.provider.getBlockNumber();
        chain.lastExpressedBlock = chain.lastRelayedBlock;
        yield chain.deployConstAddressDeployer();
        yield chain.deployCreate3Deployer();
        yield chain.deployGateway();
        yield chain.deployGasReceiver();
        chain.tokens = {};
        //chain.usdc = await chain.deployToken('Axelar Wrapped aUSDC', 'aUSDC', 6, BigInt(1e70));
        Network_1.networks.push(chain);
        return chain;
    });
}
exports.setupNetwork = setupNetwork;
function forkNetwork(chainInfo, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (options.dbPath && fs_1.default.existsSync(options.dbPath + '/networkInfo.json')) {
            throw new Error('Not supported, bug foivos if you need to fork and archive chains');
        }
        const chain = new Network_1.Network();
        chain.name = options.name != null ? options.name : chainInfo.name != null ? chainInfo.name : `Chain ${Network_1.networks.length + 1}`;
        chain.chainId = options.chainId || chainInfo.chainId || Network_1.networks.length + 2500;
        utils_1.logger.log(`Forking ${chain.name} with a chainId of ${chain.chainId}...`);
        const accounts = (0, utils_1.defaultAccounts)(20, options.seed);
        //This section gets the admin accounts so we can unlock them in our fork to upgrade the gateway to a 'localized' version
        const forkProvider = (0, ethers_1.getDefaultProvider)(chainInfo.rpc);
        const gateway = AxelarGateway__factory_1.AxelarGateway__factory.connect(chainInfo.gateway, forkProvider);
        const KEY_ADMIN_EPOCH = keccak256(toUtf8Bytes('admin-epoch'));
        const adminEpoch = yield gateway.getUint(KEY_ADMIN_EPOCH);
        const PREFIX_ADMIN_THRESHOLD = keccak256(toUtf8Bytes('admin-threshold'));
        const thresholdKey = keccak256(solidityPack(['bytes32', 'uint256'], [PREFIX_ADMIN_THRESHOLD, adminEpoch]));
        const oldThreshold = yield gateway.getUint(thresholdKey).then((x) => x.toNumber());
        const oldAdminAddresses = [];
        for (let i = 0; i < oldThreshold; i++) {
            const PREFIX_ADMIN = keccak256(toUtf8Bytes('admin'));
            const adminKey = keccak256(solidityPack(['bytes32', 'uint256', 'uint256'], [PREFIX_ADMIN, adminEpoch, i]));
            const address = yield gateway.getAddress(adminKey);
            oldAdminAddresses.push(address);
        }
        const ganacheOptions = {
            database: { dbPath: options.dbPath },
            wallet: {
                accounts: accounts,
                unlockedAccounts: oldAdminAddresses,
            },
            chain: {
                chainId: chain.chainId,
                networkId: chain.chainId,
                vmErrorsOnRPCResponse: true,
            },
            fork: {
                url: chainInfo.rpc,
            },
            logging: { quiet: true },
        };
        const merged = (0, lodash_1.merge)(ganacheOptions, options.ganacheOptions);
        chain.ganacheProvider = ganache_1.default.provider(merged);
        chain.provider = new ethers_1.providers.Web3Provider(chain.ganacheProvider);
        const wallets = accounts.map((x) => new ethers_1.Wallet(x.secretKey, chain.provider));
        chain.userWallets = wallets.splice(10, 20);
        [chain.ownerWallet, chain.operatorWallet, chain.relayerWallet] = wallets;
        chain.adminWallets = wallets.splice(4, 10);
        chain.threshold = 3;
        chain.lastRelayedBlock = yield chain.provider.getBlockNumber();
        chain.lastExpressedBlock = chain.lastRelayedBlock;
        chain.constAddressDeployer = new ethers_1.Contract(chainInfo.constAddressDeployer, contracts_1.ConstAddressDeployer.abi, chain.provider);
        // Delete the line below and uncomment the line after when we deploy create3Deployer
        yield chain.deployCreate3Deployer();
        //chain.create3Deployer = new Contract(chainInfo.create3Deployer, Create3Deployer.abi, chain.provider);
        chain.gateway = AxelarGateway__factory_1.AxelarGateway__factory.connect(chainInfo.gateway, chain.provider);
        yield chain._upgradeGateway(oldAdminAddresses, oldThreshold);
        chain.gasService = AxelarGasService__factory_1.AxelarGasService__factory.connect(chainInfo.AxelarGasService.address, chain.provider);
        chain.tokens = {
            uusdc: chain.name === 'Ethereum' ? 'USDC' : 'axlUSDC',
            uausdc: 'aUSDC',
        };
        if (options.port) {
            chain.port = options.port;
            chain.server = (0, server_1.default)(chain).listen(chain.port, () => {
                utils_1.logger.log(`Serving ${chain.name} on port ${chain.port}`);
            });
        }
        if (options.dbPath) {
            (0, utils_1.setJSON)(chain.getInfo(), options.dbPath + '/networkInfo.json');
        }
        Network_1.networks.push(chain);
        return chain;
    });
}
exports.forkNetwork = forkNetwork;
function stop(network) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof network === 'string')
            network = Network_1.networks.find((chain) => chain.name === network);
        if (network.server)
            yield network.server.close();
        Network_1.networks.splice(Network_1.networks.indexOf(network), 1);
    });
}
exports.stop = stop;
function stopAll() {
    return __awaiter(this, void 0, void 0, function* () {
        while (Network_1.networks.length > 0) {
            yield stop(Network_1.networks[0]);
        }
        if (serverInstance) {
            yield serverInstance.close();
            serverInstance = undefined;
        }
    });
}
exports.stopAll = stopAll;
exports.depositAddresses = {};
function getDepositAddress(from, to, destinationAddress, alias, port = undefined) {
    if (typeof from != 'string')
        from = from.name;
    if (typeof to != 'string')
        to = to.name;
    if (!port) {
        const key = keccak256(id(from + ':' + to + ':' + destinationAddress + ':' + alias));
        const address = new ethers_1.Wallet(key).address;
        exports.depositAddresses[from] = {
            [address]: {
                destinationChain: to,
                destinationAddress: destinationAddress,
                alias: alias,
                privateKey: key,
            },
        };
        return address;
    }
    return (0, utils_1.httpGet)(`http:/localhost:${port}/getDepositAddress/${from}/${to}/${destinationAddress}/${alias}`);
}
exports.getDepositAddress = getDepositAddress;
//# sourceMappingURL=networkUtils.js.map