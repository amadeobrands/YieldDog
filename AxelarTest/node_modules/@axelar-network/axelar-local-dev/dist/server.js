"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const http_1 = require("http");
const networkUtils_1 = require("./networkUtils");
const relay_1 = require("./relay");
const hasOwnProperty = Object.prototype.hasOwnProperty;
function createCORSResponseHeaders(method, requestHeaders) {
    // https://fetch.spec.whatwg.org/#http-requests
    const headers = {};
    const isCORSRequest = hasOwnProperty.call(requestHeaders, 'origin');
    if (isCORSRequest) {
        // OPTIONS preflight requests need a little extra treatment
        if (method === 'OPTIONS') {
            // we only allow POST requests, so it doesn't matter which method the request is asking for
            headers['Access-Control-Allow-Methods'] = 'POST';
            // echo all requested access-control-request-headers back to the response
            if (hasOwnProperty.call(requestHeaders, 'access-control-request-headers')) {
                headers['Access-Control-Allow-Headers'] = requestHeaders['access-control-request-headers'];
            }
            // Safari needs Content-Length = 0 for a 204 response otherwise it hangs forever
            // https://github.com/expressjs/cors/pull/121#issue-130260174
            headers['Content-Length'] = 0;
            // Make browsers and compliant clients cache the OPTIONS preflight response for 10
            // minutes (this is the maximum time Chromium allows)
            headers['Access-Control-Max-Age'] = 600; // seconds
        }
        // From the spec: https://fetch.spec.whatwg.org/#http-responses
        // "For a CORS-preflight request, requestâ€™s credentials mode is always "omit",
        // but for any subsequent CORS requests it might not be. Support therefore
        // needs to be indicated as part of the HTTP response to the CORS-preflight request as well.", so this
        // header is added to all requests.
        // Additionally, https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials,
        // states that there aren't any HTTP Request headers that indicate you whether or not Request.withCredentials
        // is set. Because web3@1.0.0-beta.35-? always sets `request.withCredentials = true` while Safari requires it be
        // returned even when no credentials are set in the browser this header must always be return on all requests.
        // (I've found that Chrome and Firefox don't actually require the header when credentials aren't set)
        //  Regression Commit: https://github.com/ethereum/web3.js/pull/1722
        //  Open Web3 Issue: https://github.com/ethereum/web3.js/issues/1802
        headers['Access-Control-Allow-Credentials'] = 1;
        // From the spec: "It cannot be reliably identified as participating in the CORS protocol
        // as the `Origin` header is also included for all requests whose method is neither
        // `GET` nor `HEAD`."
        // Explicitly set the origin instead of using *, since credentials
        // can't be used in conjunction with *. This will always be set
        /// for valid preflight requests.
        headers['Access-Control-Allow-Origin'] = requestHeaders.origin;
    }
    return headers;
}
function sendResponse(response, statusCode, headers, data = null) {
    response.writeHead(statusCode, headers);
    response.end(data);
}
function rpcError(id, code, msg) {
    return JSON.stringify({
        jsonrpc: '2.0',
        id: id,
        error: {
            code: code,
            message: msg,
        },
    });
}
// eslint-disable-next-line @typescript-eslint/no-empty-function
function default_1(networkOrList, logger = { log: function (...args) { } }) {
    const server = (0, http_1.createServer)(function (request, response) {
        const method = request.method;
        const chunks = [];
        request
            .on('data', function (chunk) {
            chunks.push(chunk);
        })
            .on('end', function () {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const body = Buffer.concat(chunks).toString();
                // At this point, we have the headers, method, url and body, and can now
                // do whatever we need to in order to respond to this request.
                const headers = createCORSResponseHeaders(method, request.headers);
                const badRequest = () => {
                    headers['Content-Type'] = 'text/plain';
                    sendResponse(response, 400, headers, '400 Bad Request');
                };
                let network;
                const url = (_a = request.url) === null || _a === void 0 ? void 0 : _a.split('/');
                if (!url)
                    return;
                url === null || url === void 0 ? void 0 : url.shift();
                if (Array.isArray(networkOrList)) {
                    if ((url === null || url === void 0 ? void 0 : url.length) == 0) {
                        badRequest();
                        return;
                    }
                    const first = url === null || url === void 0 ? void 0 : url.shift();
                    if (first == 'info' && method == 'GET') {
                        headers['Content-Type'] = 'application/json';
                        sendResponse(response, 200, headers, JSON.stringify(networkOrList.length));
                        return;
                    }
                    if (first == 'getDepositAddress' && method == 'GET') {
                        headers['Content-Type'] = 'application/json';
                        const from = url[0].replace('%20', ' ');
                        const to = url[1].replace('%20', ' ');
                        const destinationAddress = url[2];
                        const symbol = url[3];
                        sendResponse(response, 200, headers, JSON.stringify((0, networkUtils_1.getDepositAddress)(from, to, destinationAddress, symbol)));
                        return;
                    }
                    const n = parseInt(first);
                    if (Number.isNaN(n) || n < 0 || n >= networkOrList.length) {
                        badRequest();
                        return;
                    }
                    network = networkOrList[n];
                }
                else {
                    network = networkOrList;
                }
                switch (method) {
                    case 'POST':
                        // eslint-disable-next-line no-case-declarations
                        let payload;
                        try {
                            payload = JSON.parse(body);
                        }
                        catch (e) {
                            badRequest();
                            return;
                        }
                        // Log messages that come into the TestRPC via http
                        if (payload instanceof Array) {
                            // Batch request
                            for (let i = 0; i < payload.length; i++) {
                                const item = payload[i];
                                logger.log(item.method);
                            }
                        }
                        else {
                            logger.log(payload.method);
                        }
                        // http connections do not support subscriptions
                        if (payload.method === 'eth_subscribe' || payload.method === 'eth_unsubscribe') {
                            headers['Content-Type'] = 'application/json';
                            sendResponse(response, 400, headers, rpcError(payload.id, -32000, 'notifications not supported'));
                            break;
                        }
                        if (network == null) {
                            badRequest();
                            return;
                        }
                        network.ganacheProvider.send(payload, function (_, result) {
                            headers['Content-Type'] = 'application/json';
                            sendResponse(response, 200, headers, JSON.stringify(result));
                        });
                        break;
                    case 'OPTIONS':
                        sendResponse(response, 204, headers);
                        break;
                    case 'GET':
                        if (url.length == 0) {
                            badRequest();
                            break;
                        }
                        if (url[0] == 'info') {
                            headers['Content-Type'] = 'application/json';
                            sendResponse(response, 200, headers, JSON.stringify(network.getInfo()));
                        }
                        else if (url[0] == 'relay') {
                            response.writeHead(200, { 'Content-Type': 'application/json' });
                            logger.log(`Relaying from ${network.name}.`);
                            yield (0, relay_1.relay)();
                            response.end(JSON.stringify('Relayed!'));
                        }
                        else {
                            badRequest();
                        }
                        break;
                    default:
                        badRequest();
                        break;
                }
            });
        });
    });
    return server;
}
exports.default = default_1;
//# sourceMappingURL=server.js.map