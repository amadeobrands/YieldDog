"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmRelayer = void 0;
const Relayer_1 = require("./Relayer");
const ethers_1 = require("ethers");
const utils_1 = require("../utils");
const Command_1 = require("./Command");
const utils_2 = require("ethers/lib/utils");
const networkUtils_1 = require("../networkUtils");
const Network_1 = require("../Network");
const networkUtils_2 = require("../networkUtils");
const AxelarExpressExecutable__factory_1 = require("../types/factories/@axelar-network/axelar-gmp-sdk-solidity/contracts/express/AxelarExpressExecutable__factory");
const AddressZero = ethers_1.ethers.constants.AddressZero;
class EvmRelayer extends Relayer_1.Relayer {
    constructor(options = {}) {
        super();
        this.eventSubscribers = [];
        this.otherRelayers.near = options.nearRelayer;
        this.otherRelayers.aptos = options.aptosRelayer;
    }
    setRelayer(type, relayer) {
        this.otherRelayers[type] = relayer;
    }
    updateEvents() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const from of Network_1.networks) {
                const blockNumber = yield from.provider.getBlockNumber();
                if (blockNumber <= from.lastRelayedBlock)
                    continue;
                yield this.updateGasEvents(from, blockNumber);
                yield this.updateExpressGasEvents(from, blockNumber);
                yield this.updateDepositAddresses(from, blockNumber);
                yield this.updateTokenSentEvent(from, blockNumber);
                yield this.updateCallContractEvents(from, blockNumber);
                yield this.updateCallContractWithTokensEvents(from, blockNumber);
                from.lastRelayedBlock = blockNumber;
            }
        });
    }
    execute(commands) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.executeEvm(commands);
            for (const relayerType in this.otherRelayers) {
                yield ((_a = this.otherRelayers[relayerType]) === null || _a === void 0 ? void 0 : _a.execute(commands));
            }
        });
    }
    subscribeExpressCall() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const chain of Network_1.networks) {
                if (!this.commands[chain.name]) {
                    this.commands[chain.name] = [];
                }
            }
            for (const chain of Network_1.networks) {
                const subscriber = chain.gasService.on('NativeGasPaidForExpressCallWithToken', (_sourceAddress, destinationChain) => __awaiter(this, void 0, void 0, function* () {
                    const blockNumber = yield chain.provider.getBlockNumber();
                    yield this.updateExpressGasEvents(chain, blockNumber);
                    yield this.updateCallContractWithTokensEvents(chain, blockNumber, chain.lastExpressedBlock + 1);
                    const destChain = Network_1.networks.find((network) => network.name === destinationChain);
                    if (!destChain)
                        return;
                    const commands = this.commands[destinationChain];
                    if (!commands || (commands === null || commands === void 0 ? void 0 : commands.length) === 0)
                        return;
                    yield this.executeEvmExpress(destChain, commands).catch((e) => {
                        utils_1.logger.log(e);
                    });
                    chain.lastExpressedBlock = blockNumber;
                }));
                this.eventSubscribers.push(subscriber);
            }
        });
    }
    unsubscribe() {
        this.eventSubscribers.forEach((subscriber) => {
            subscriber.removeAllListeners();
        });
    }
    executeEvm(commandList) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const to of Network_1.networks) {
                const commands = commandList[to.name];
                if (!commands || (commands === null || commands === void 0 ? void 0 : commands.length) === 0)
                    continue;
                yield this.executeEvmGateway(to, commands);
                yield this.executeEvmExecutable(to, commands);
            }
        });
    }
    executeEvmGateway(to, commands) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = (0, utils_2.arrayify)(utils_2.defaultAbiCoder.encode(['uint256', 'bytes32[]', 'string[]', 'bytes[]'], [to.chainId, commands.map((com) => com.commandId), commands.map((com) => com.name), commands.map((com) => com.encodedData)]));
            const signedData = yield (0, utils_1.getSignedExecuteInput)(data, to.operatorWallet);
            return to.gateway
                .connect(to.ownerWallet)
                .execute(signedData, { gasLimit: BigInt(8e6) })
                .then((tx) => tx.wait());
        });
    }
    executeEvmExpress(to, commands) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const command of commands) {
                if (command.post === null)
                    continue;
                const executed = yield this.isExecuted(to, command);
                // If the command has already been approved, skip it.
                if (executed)
                    continue;
                const fromName = command.data[0];
                const from = Network_1.networks.find((network) => network.name === fromName);
                if (!from)
                    continue;
                const payed = this.expressContractCallWithTokenGasEvents.find((log) => {
                    if (log.sourceAddress.toLowerCase() !== command.data[1].toLowerCase())
                        return false;
                    if (log.destinationChain.toLowerCase() !== to.name.toLowerCase())
                        return false;
                    if (log.destinationAddress.toLowerCase() !== command.data[2].toLowerCase())
                        return false;
                    if (log.payloadHash.toLowerCase() !== command.data[3].toLowerCase())
                        return false;
                    const alias = this.getAliasFromSymbol(from.tokens, log.symbol);
                    if (to.tokens[alias] !== command.data[4])
                        return false;
                    if (!command.data[5].eq(log.amount))
                        return false;
                    return true;
                });
                if (!payed)
                    continue;
                const cost = (0, networkUtils_2.getGasPrice)();
                const blockLimit = Number((yield to.provider.getBlock('latest')).gasLimit);
                const gasLimit = BigInt(Math.min(blockLimit, payed.gasFeeAmount / cost));
                const { payload } = this.relayData.callContractWithToken[command.commandId];
                const expressExecutorContract = AxelarExpressExecutable__factory_1.AxelarExpressExecutable__factory.connect(payed.destinationAddress, to.relayerWallet);
                const tokenAddress = yield to.gateway.tokenAddresses(to.tokens[payed.symbol]);
                const tokenContract = new ethers_1.ethers.Contract(tokenAddress, [
                    'function allowance(address,address) view returns (uint256)',
                    'function approve(address,uint256)',
                    'function balanceOf(address) view returns (uint256)',
                ], to.relayerWallet);
                // fund relayer wallet with token
                const balance = yield tokenContract.balanceOf(to.relayerWallet.address);
                if (balance.lt(payed.amount)) {
                    const fundAmount = ethers_1.ethers.BigNumber.from(1e10);
                    yield to.giveToken(to.relayerWallet.address, payed.symbol, fundAmount.gt(payed.amount) ? fundAmount.toBigInt() : payed.amount);
                }
                const allowance = yield tokenContract.allowance(to.relayerWallet.address, expressExecutorContract.address);
                // If the allowance is insufficient, approve the contract
                if (allowance.lt(payed.amount)) {
                    yield tokenContract.approve(expressExecutorContract.address, ethers_1.ethers.constants.MaxUint256).then((tx) => tx.wait());
                }
                yield expressExecutorContract
                    .expressExecuteWithToken(command.commandId, fromName, payed.sourceAddress, payload, payed.symbol, payed.amount, {
                    gasLimit,
                })
                    .then((tx) => tx.wait())
                    .catch(() => undefined);
            }
        });
    }
    executeEvmExecutable(to, commands) {
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, function* () {
            for (const command of commands) {
                // If the command doesn't have post execution, skip it
                if (command.post === null)
                    continue;
                // If the command has not approved yet, skip it
                const executed = yield this.isExecuted(to, command);
                if (!executed)
                    continue;
                // Find the network that the command is executed on
                const fromName = command.data[0];
                const from = Network_1.networks.find((network) => network.name === fromName);
                // If the network is not found, skip it
                if (!from)
                    continue;
                // Find the gas event that matches the command
                const { event: gasPaidEvent, gasEventIndex } = this.findMatchedGasEvent(command, from, to);
                // If the gas event is not found, skip it
                if (!gasPaidEvent || gasEventIndex === -1)
                    continue;
                try {
                    const cost = (0, networkUtils_2.getGasPrice)();
                    // Get the block gas limit
                    const blockGasLimit = yield from.provider.getBlock('latest').then((block) => block.gasLimit);
                    const filterUnmatchedGasEvents = (_, index) => {
                        return index !== gasEventIndex;
                    };
                    if (command.name === 'approveContractCall') {
                        this.contractCallGasEvents = this.contractCallGasEvents.filter(filterUnmatchedGasEvents);
                    }
                    else {
                        this.contractCallWithTokenGasEvents = this.contractCallWithTokenGasEvents.filter(filterUnmatchedGasEvents);
                        this.expressContractCallWithTokenGasEvents =
                            this.expressContractCallWithTokenGasEvents.filter(filterUnmatchedGasEvents);
                    }
                    // Execute the command
                    const paidGasLimit = gasPaidEvent.gasFeeAmount.div(cost);
                    const receipt = yield ((_a = command.post) === null || _a === void 0 ? void 0 : _a.call(command, {
                        gasLimit: blockGasLimit.lt(paidGasLimit) ? blockGasLimit : paidGasLimit,
                    }));
                    // check two-ways contract call
                    if (receipt === null || receipt === void 0 ? void 0 : receipt.events) {
                        const contractCallEventTopic = (_c = (_b = to.gateway.filters.ContractCall()) === null || _b === void 0 ? void 0 : _b.topics) === null || _c === void 0 ? void 0 : _c[0];
                        const contractCallWithTokenEventTopic = (_e = (_d = to.gateway.filters.ContractCallWithToken()) === null || _d === void 0 ? void 0 : _d.topics) === null || _e === void 0 ? void 0 : _e[0];
                        const contractInterface = to.gateway.interface;
                        for (const _event of receipt.events) {
                            if (((_f = _event.topics) === null || _f === void 0 ? void 0 : _f[0]) === contractCallEventTopic) {
                                // Note: cast to any as workaround for the opened issue in typechain https://github.com/dethcrypto/TypeChain/issues/736
                                const contractCallEvent = contractInterface.decodeEventLog('ContractCall', _event.data, _event.topics);
                                const _newGasPaidEvent = Object.assign(Object.assign({}, gasPaidEvent), { sourceAddress: contractCallEvent.sender, destinationAddress: contractCallEvent.destinationContractAddress, destinationChain: contractCallEvent.destinationChain, payloadHash: contractCallEvent.payloadHash, gasFeeAmount: gasPaidEvent.gasFeeAmount.sub(receipt.gasUsed.mul(cost)) });
                                this.contractCallGasEvents.push(_newGasPaidEvent);
                            }
                            else if (((_g = _event.topics) === null || _g === void 0 ? void 0 : _g[0]) === contractCallWithTokenEventTopic) {
                                // Note: cast to any as workaround for the opened issue in typechain https://github.com/dethcrypto/TypeChain/issues/736
                                const contractCallWithTokenEvent = contractInterface.decodeEventLog('ContractCallWithToken', _event.data, _event.topics);
                                const _newGasWithTokenPaidEvent = Object.assign(Object.assign({}, gasPaidEvent), { sourceAddress: contractCallWithTokenEvent.sender, destinationAddress: contractCallWithTokenEvent.destinationContractAddress, destinationChain: contractCallWithTokenEvent.destinationChain, payloadHash: contractCallWithTokenEvent.payloadHash, symbol: contractCallWithTokenEvent.symbol, amount: contractCallWithTokenEvent.amount, gasFeeAmount: gasPaidEvent.gasFeeAmount.sub(receipt.gasUsed.mul(cost)) });
                                this.contractCallWithTokenGasEvents.push(_newGasWithTokenPaidEvent);
                            }
                        }
                    }
                }
                catch (e) {
                    utils_1.logger.log(e);
                }
            }
        });
    }
    isExecuted(to, command) {
        return to.gateway.isCommandExecuted(command.commandId);
    }
    findMatchedGasEvent(command, from, to) {
        if (command.name === 'approveContractCall') {
            const event = this.contractCallGasEvents.find((event) => {
                if (event.sourceAddress.toLowerCase() !== command.data[1].toLowerCase())
                    return false;
                if (event.destinationChain.toLowerCase() !== to.name.toLowerCase())
                    return false;
                if (event.destinationAddress.toLowerCase() !== command.data[2].toLowerCase())
                    return false;
                if (event.payloadHash.toLowerCase() !== command.data[3].toLowerCase())
                    return false;
                return true;
            });
            return { event, eventIndex: this.contractCallGasEvents.indexOf(event) };
        }
        else {
            const gmpGasEvent = this.contractCallWithTokenGasEvents.find((event) => {
                if (event.sourceAddress.toLowerCase() !== command.data[1].toLowerCase())
                    return false;
                if (event.destinationChain.toLowerCase() !== to.name.toLowerCase())
                    return false;
                if (event.destinationAddress.toLowerCase() !== command.data[2].toLowerCase())
                    return false;
                if (event.payloadHash.toLowerCase() !== command.data[3].toLowerCase())
                    return false;
                const alias = this.getAliasFromSymbol(from.tokens, event.symbol);
                if (to.tokens[alias] !== command.data[4])
                    return false;
                if (!event.amount.eq(command.data[5]))
                    return false;
                return true;
            });
            const expressGmpGasEvent = this.expressContractCallWithTokenGasEvents.find((log) => {
                if (log.sourceAddress.toLowerCase() !== command.data[1].toLowerCase())
                    return false;
                if (log.destinationChain.toLowerCase() !== to.name.toLowerCase())
                    return false;
                if (log.destinationAddress.toLowerCase() !== command.data[2].toLowerCase())
                    return false;
                if (log.payloadHash.toLowerCase() !== command.data[3].toLowerCase())
                    return false;
                const alias = this.getAliasFromSymbol(from.tokens, log.symbol);
                if (to.tokens[alias] !== command.data[4])
                    return false;
                if (!command.data[5].eq(log.amount))
                    return false;
                return true;
            });
            return gmpGasEvent
                ? {
                    event: gmpGasEvent,
                    eventIndex: this.contractCallWithTokenGasEvents.indexOf(gmpGasEvent),
                }
                : {
                    event: expressGmpGasEvent,
                    eventIndex: this.expressContractCallWithTokenGasEvents.indexOf(expressGmpGasEvent),
                };
        }
    }
    updateGasEvents(from, blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const gasPaidForContractCallFilter = from.gasService.filters.GasPaidForContractCall();
            const gasPaidForContractCallLogs = (yield from.gasService.queryFilter(gasPaidForContractCallFilter, from.lastRelayedBlock + 1, blockNumber)).map((log) => log.args);
            for (const gasLog of gasPaidForContractCallLogs) {
                this.contractCallGasEvents.push(gasLog);
            }
            const nativeGasPaidForContractCallFilter = from.gasService.filters.NativeGasPaidForContractCall();
            const nativeGasPaidForContractCallLogs = (yield from.gasService.queryFilter(nativeGasPaidForContractCallFilter, from.lastRelayedBlock + 1, blockNumber)).map((log) => {
                return Object.assign(Object.assign({}, log.args), { gasToken: AddressZero });
            });
            for (const gasLog of nativeGasPaidForContractCallLogs) {
                this.contractCallGasEvents.push(gasLog);
            }
            const gasPaidForContractCallWithTokenFilter = from.gasService.filters.GasPaidForContractCallWithToken();
            const gasPaidForContractCallWithToken = (yield from.gasService.queryFilter(gasPaidForContractCallWithTokenFilter, from.lastRelayedBlock + 1, blockNumber)).map((log) => log.args);
            for (const gasLog of gasPaidForContractCallWithToken) {
                this.contractCallWithTokenGasEvents.push(gasLog);
            }
            const nativeGasPaidForContractCallWithTokenFilter = from.gasService.filters.NativeGasPaidForContractCallWithToken();
            const nativeGasPaidForContractCallWithToken = (yield from.gasService.queryFilter(nativeGasPaidForContractCallWithTokenFilter, from.lastRelayedBlock + 1, blockNumber)).map((log) => {
                return Object.assign(Object.assign({}, log.args), { gasToken: AddressZero });
            });
            for (const gasLog of nativeGasPaidForContractCallWithToken) {
                this.contractCallWithTokenGasEvents.push(gasLog);
            }
        });
    }
    updateExpressGasEvents(from, blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            let filter = from.gasService.filters.GasPaidForExpressCallWithToken();
            let newGasLogs = (yield from.gasService.queryFilter(filter, from.lastExpressedBlock + 1, blockNumber)).map((log) => log.args);
            for (const gasLog of newGasLogs) {
                this.expressContractCallWithTokenGasEvents.push(gasLog);
            }
            filter = from.gasService.filters.NativeGasPaidForExpressCallWithToken();
            newGasLogs = (yield from.gasService.queryFilter(filter, from.lastExpressedBlock + 1, blockNumber)).map((log) => {
                return Object.assign(Object.assign({}, log.args), { gasToken: AddressZero });
            });
            for (const gasLog of newGasLogs) {
                this.expressContractCallWithTokenGasEvents.push(gasLog);
            }
        });
    }
    updateCallContractEvents(from, blockNumber) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const filter = from.gateway.filters.ContractCall();
            const logsFrom = yield from.gateway.queryFilter(filter, from.lastRelayedBlock + 1, blockNumber);
            for (const log of logsFrom) {
                const tx = yield log.getTransaction();
                const transactionHash = tx.hash;
                const sourceEventIndex = log.logIndex;
                const args = log.args;
                if (this.commands[args.destinationChain] === null)
                    continue;
                const commandId = (0, utils_1.getEVMLogID)(from.name, log);
                const contractCallArgs = {
                    from: from.name,
                    to: args.destinationChain,
                    sourceAddress: args.sender,
                    destinationContractAddress: args.destinationContractAddress,
                    payload: args.payload,
                    payloadHash: args.payloadHash,
                    transactionHash,
                    sourceEventIndex,
                };
                this.relayData.callContract[commandId] = contractCallArgs;
                let command;
                if (args.destinationChain.toLowerCase() === 'aptos') {
                    command = (_b = (_a = this.otherRelayers) === null || _a === void 0 ? void 0 : _a.aptos) === null || _b === void 0 ? void 0 : _b.createCallContractCommand(commandId, this.relayData, contractCallArgs);
                }
                else if (args.destinationChain.toLowerCase() == 'near') {
                    command = (_d = (_c = this.otherRelayers) === null || _c === void 0 ? void 0 : _c.near) === null || _d === void 0 ? void 0 : _d.createCallContractCommand(commandId, this.relayData, contractCallArgs);
                }
                else {
                    command = this.createCallContractCommand(commandId, this.relayData, contractCallArgs);
                }
                if (command) {
                    this.commands[args.destinationChain].push(command);
                }
            }
        });
    }
    createCallContractCommand(commandId, relayData, contractCallArgs) {
        return Command_1.Command.createEVMContractCallCommand(commandId, relayData, contractCallArgs);
    }
    createCallContractWithTokenCommand(commandId, relayData, callContractWithTokenArgs) {
        return Command_1.Command.createEVMContractCallWithTokenCommand(commandId, relayData, callContractWithTokenArgs);
    }
    updateTokenSentEvent(from, blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const filter = from.gateway.filters.TokenSent();
            const logsFrom = yield from.gateway.queryFilter(filter, from.lastRelayedBlock + 1, blockNumber);
            for (const log of logsFrom) {
                const args = log.args;
                const alias = this.getAliasFromSymbol(from.tokens, args.symbol);
                const fee = (0, networkUtils_2.getFee)();
                if (args.amount <= fee)
                    continue;
                const amountOut = args.amount.sub(fee);
                const commandId = (0, utils_1.getEVMLogID)(from.name, log);
                const to = Network_1.networks.find((chain) => chain.name === args.destinationChain);
                if (!to)
                    return;
                const destinationTokenSymbol = to.tokens[alias];
                this.relayData.sendToken[commandId] = {
                    from: from.name,
                    to: args.destinationChain,
                    amountIn: args.amount,
                    fee: fee,
                    alias: alias,
                    amountOut: amountOut,
                };
                this.commands[args.destinationChain].push(new Command_1.Command(commandId, 'mintToken', [destinationTokenSymbol, args.destinationAddress, amountOut], ['string', 'address', 'uint256'], args.destinationChain));
            }
        });
    }
    updateCallContractWithTokensEvents(from, toBlock, fromBlock = from.lastRelayedBlock + 1) {
        return __awaiter(this, void 0, void 0, function* () {
            const filter = from.gateway.filters.ContractCallWithToken();
            const logsFrom = yield from.gateway.queryFilter(filter, fromBlock, toBlock);
            for (const log of logsFrom) {
                const args = log.args;
                if (!this.commands[args.destinationChain])
                    continue;
                const alias = this.getAliasFromSymbol(from.tokens, args.symbol);
                const amountOut = args.amount;
                const commandId = (0, utils_1.getEVMLogID)(from.name, log);
                const to = Network_1.networks.find((chain) => chain.name === args.destinationChain);
                if (!to)
                    return;
                const destinationTokenSymbol = to.tokens[alias];
                const callContractWithTokenArgs = {
                    from: from.name,
                    to: args.destinationChain,
                    sourceAddress: args.sender,
                    destinationContractAddress: args.destinationContractAddress,
                    payload: args.payload,
                    payloadHash: args.payloadHash,
                    alias: alias,
                    destinationTokenSymbol,
                    amountIn: args.amount,
                    amountOut: amountOut,
                };
                this.relayData.callContractWithToken[commandId] = callContractWithTokenArgs;
                const command = this.createCallContractWithTokenCommand(commandId, this.relayData, callContractWithTokenArgs);
                this.commands[args.destinationChain].push(command);
            }
        });
    }
    updateDepositAddresses(from, blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const address in networkUtils_1.depositAddresses[from.name]) {
                const data = networkUtils_1.depositAddresses[from.name][address];
                const tokenSymbol = from.tokens[data.alias];
                const token = yield from.getTokenContract(tokenSymbol);
                const fee = (0, networkUtils_2.getFee)();
                const balance = yield token.balanceOf(address);
                const to = Network_1.networks.find((chain) => chain.name === data.destinationChain);
                if (!to)
                    continue;
                const destinationTokenSymbol = to.tokens[data.alias];
                if (balance > fee) {
                    const commandId = (0, utils_1.getRandomID)();
                    this.relayData.depositAddress[commandId] = {
                        from: from.name,
                        to: data.destinationChain,
                        amountIn: balance,
                        fee: fee,
                        amountOut: balance - fee,
                    };
                    this.commands[data.destinationChain].push(new Command_1.Command(commandId, 'mintToken', [destinationTokenSymbol, data.destinationAddress, balance - fee], ['string', 'address', 'uint256']));
                    const wallet = new ethers_1.Wallet(data.privateKey, from.provider);
                    if (Number(yield from.provider.getBalance(address)) === 0) {
                        // Create a transaction object
                        const tx = {
                            to: address,
                            // Convert currency unit from ether to wei
                            value: BigInt(1e16),
                        };
                        // Send a transaction
                        yield (yield from.ownerWallet.sendTransaction(tx)).wait();
                    }
                    yield (yield token.connect(wallet).transfer(from.ownerWallet.address, balance)).wait();
                }
            }
        });
    }
    getAliasFromSymbol(tokens, symbol) {
        for (const alias in tokens) {
            if (tokens[alias] === symbol)
                return alias;
        }
        return '';
    }
}
exports.EvmRelayer = EvmRelayer;
//# sourceMappingURL=EvmRelayer.js.map